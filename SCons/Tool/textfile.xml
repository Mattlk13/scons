<?xml version="1.0"?>
<!--
SPDX-FileCopyrightText: Copyright The SCons Foundation (https://scons.org)
SPDX-License-Identifier: MIT
SPDX-FileType: DOCUMENTATION

This file is processed by the bin/SConsDoc.py module.
-->

<!DOCTYPE sconsdoc [
<!ENTITY % scons SYSTEM '../../doc/scons.mod'>
%scons;
<!ENTITY % builders-mod SYSTEM '../../doc/generated/builders.mod'>
%builders-mod;
<!ENTITY % functions-mod SYSTEM '../../doc/generated/functions.mod'>
%functions-mod;
<!ENTITY % tools-mod SYSTEM '../../doc/generated/tools.mod'>
%tools-mod;
<!ENTITY % variables-mod SYSTEM '../../doc/generated/variables.mod'>
%variables-mod;
]>

<sconsdoc xmlns="http://www.scons.org/dbxsd/v1.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.scons.org/dbxsd/v1.0 http://www.scons.org/dbxsd/v1.0/scons.xsd">

<tool name="textfile">
<summary>
<para>
Set &consvars; for the &b-link-Textfile; and &b-link-Substfile; builders.
</para>
</summary>
<sets>
<item>LINESEPARATOR</item>
<item>SUBSTFILEPREFIX</item>
<item>SUBSTFILESUFFIX</item>
<item>TEXTFILEPREFIX</item>
<item>TEXTFILESUFFIX</item>
<item>FILE_ENCODING</item>
</sets>
<uses>
<item>SUBST_DICT</item>
</uses>
</tool>

<builder name="Textfile">
<summary>
<para>
The &b-Textfile; builder and its sibling &b-Substfile;
create a single text file by combining one or more template inputs,
optionally performing token replacement.
&b-Textfile; operates on string-like sources.
Inputs are converted to SCons &f-link-Value; nodes so they can
be tracked for rebuild purposes.
Anything that converts cleanly to a &f-Value; node
is eligible to be an input source, XXX
so you can use files as string input by using,
for example, <literal>Value('foo.in')</literal>.
If there is more than one source,
corresponding text chunks in the output are separated by
the contents of the &cv-link-LINESEPARATOR; &consvar; (if set).
If the &cv-link-SUBST_DICT; &consvar; is set,
it defines replaceable strings and the replacement text.
The replacement values are first subjected to
&consvar; substitution.
Nested lists of source strings are flattened.
See &b-link-Substfile; for more details of replacement.
</para>

<para>
The prefix and suffix specified by the &cv-link-TEXTFILEPREFIX;
and &cv-link-TEXTFILESUFFIX; &consvars;
(by default an empty string and <filename>.txt</filename>, respectively)
are automatically added to the target if they are not already present.
</para>
<para>
By default, the target file is encoded as <literal>utf-8</literal>.
This can be changed by setting &cv-link-FILE_ENCODING;
</para>
<para>
Examples:
</para>

<example_commands>
# builds/writes foo.txt
env.Textfile(target='foo.txt', source=['Goethe', 42, 'Schiller'])

# builds/writes bar.txt
env.Textfile(target='bar', source=['lalala', 'tanteratei'], LINESEPARATOR='|*')

# nested lists are flattened automatically
env.Textfile(target='blob', source=['lalala', ['Goethe', 42, 'Schiller'], 'tanteratei'])

# files may be used as input by wrapping them in File()
env.Textfile(
    target='concat',  # concatenate files with a marker between
    source=[File('concat1'), File('concat2')],
    LINESEPARATOR='====================\n',
)
</example_commands>

<para>Results:</para>

<para><filename>foo.txt</filename></para>
<screen>
  Goethe
  42
  Schiller
</screen>

<para><filename>bar.txt</filename></para>
<screen>
  lalala|*tanteratei
</screen>

<para><filename>blob.txt</filename></para>
<screen>
  lalala
  Goethe
  42
  Schiller
  tanteratei
</screen>

</summary>
</builder>

<builder name="Substfile">
<summary>
<para>
The &b-Substfile; builder and its sibling &b-Textfile;
create a single text file by combining one or more template inputs,
optionally performing token replacement.
&b-Substfile; operates on file sources.
If there is more than one source,
corresponding text chunks in the output are separated by
the contents of the &cv-link-LINESEPARATOR; &consvar; (if set).
If the &cv-link-SUBST_DICT; &consvar; is set,
it defines replaceable strings and the replacement text.
The replacement values are first subjected to
&consvar; substitution.
Nested lists of source files are flattened. See also &b-link-Textfile;.
</para>

<para>
By default, the target file is encoded as <literal>utf-8</literal>.
This can be changed by setting &cv-link-FILE_ENCODING;
</para>

<para>
If a single source file name is specified and has a <filename>.in</filename> suffix,
the suffix is stripped and the remainder of the name is used as the default target name.
</para>

<para>
The prefix and suffix specified by the &cv-link-SUBSTFILEPREFIX;
and &cv-link-SUBSTFILESUFFIX; &consvars;
(both default to an empty string)
are automatically added to the target file name
if they are not already present (prefixes and suffixes do not duplicate).
</para>

<para>
&cv-link-SUBST_DICT; may be either a Python dictionary or a list of
(<replaceable>key</replaceable>, <replaceable>value</replaceable>) tuples.
Any occurrence of a key in the source
is replaced by the corresponding value from the substitution dictionary,
which has first been processed by <function>subst</function>.
If the value is a Python function or other callable,
it is called (with no arguments) and the return value is used
as the replacement text.
Order matters:
if one key is a substring of another key
or if one substitution could be further expanded by another substitution,
the final result depends on the order in which the keys were seen.
Using start-and-end markers in the key text can avoid
unintentended problems (e.g. <literal>"@text@"</literal>
and <literal>"@longtext@"</literal> leaves no confusion about
what to do with <literal>"text"</literal>).
</para>


<para>Example 1: Localizing a script.
The template is <filename>script.in</filename>:
</para>

<programlisting language="sh">
#! /bin/sh
# Installation paths
PREFIX="@prefix@"
EXEC_PREFIX="@exec_prefix@"

# Script logic here
if [ -d "$PREFIX" ]; then
    echo "Installing to $EXEC_PREFIX"
fi
</programlisting>

<example_commands>
# SConstruct
env = Environment(tools=['default'])

env['prefix'] = '/usr/bin'
script_dict = {'@prefix@': '/bin', '@exec_prefix@': '$prefix'}
env.Substfile('script.in', SUBST_DICT=script_dict)
</example_commands>

<para>Output file <filename>script</filename>:</para>

<programlisting language="sh">
#! /bin/sh
# Installation paths
PREFIX="/bin"
EXEC_PREFIX="/usr/bin"

# Script logic here
if [ -d "$PREFIX" ]; then
    echo "Installing to $EXEC_PREFIX"
fi
</programlisting>

<para>Example 2: Customizing a header file which provides
version-specific program information.
The template is <filename>config.h.in</filename>:
</para>

<programlisting language="sh">
#define VERSION "%VERSION%"
#define BASEAPP "%BASE%"
</programlisting>

<example_commands>
# SConstruct
conf_dict = {'%VERSION%': '1.2.3', '%BASE%': 'MyProg'}
env.Substfile('config.h.in', SUBST_DICT=conf_dict)
</example_commands>

<para>Output file <filename>config.h</filename>:</para>

<programlisting language="sh">
#define VERSION "1.2.3"
#define BASEAPP "MyProg"
</programlisting>

<para>Example 3: Showing different ways of updating
the substitution dictionary.
Sources are
<filename>common.in</filename>,
<filename>pgm1.in</filename> and
<filename>pgm2.in</filename>.
</para>

<programlisting language="c">
// Standard header for @PROJECT@
// Build: @BUILD_ID@
</programlisting>

<programlisting language="c">
void @foo@_function() {
    // Implementation for @PROJECT@ module 1
}
</programlisting>

<programlisting language="c">
void @bar@_function() {
    // Implementation for @PROJECT@ module 2
}
</programlisting>

<example_commands>
# SConstruct
substitutions = {'@PROJECT@': 'MyProject', '@BUILD_ID@': '12345'}
env = Environment(SUBST_DICT=substitutions)
substitutions['@foo@'] = 'foo'  # won't work: override makes a copy
env['SUBST_DICT']['@bar@'] = 'bar'
env.Substfile(
    'pgm1.c',
    [Value('#include "@foo@.h"'), Value('#include "@bar@.h"'), "common.in", "pgm1.in"],
)
env.Substfile(
    'pgm2.c',
    [Value('#include "@foo@.h"'), Value('#include "@bar@.h"'), "common.in", "pgm2.in"],
)
</example_commands>

<para>Output files <filename>pgm1.c</filename>
and <filename>pgm2.c</filename>:</para>

<programlisting language="c">
#include "@foo@.h"  # note wasn't substituted
#include "bar.h"
// Standard header for MyProject
// Build: 12345

void @foo@_function() {  # note wasn't substituted
    // Implementation for MyProject module 1
}
</programlisting>

<programlisting language="c">
#include "@foo@.h"  # note wasn't substituted
#include "bar.h"
// Standard header for MyProject
// Build: 12345

void bar_function() {
    // Implementation for MyProject module 2
}
</programlisting>

</summary>
</builder>

<cvar name="LINESEPARATOR">
<summary>
<para>
The separator used by the &b-link-Substfile; and &b-link-Textfile; builders.
This value is used between sources when constructing the target.
It defaults to the current system line separator.
</para>
</summary>
</cvar>

<cvar name="SUBST_DICT">
<summary>
<para>
The dictionary used by the &b-link-Substfile; or &b-link-Textfile; builders
for substitution values.
It can be anything acceptable to the <function>dict()</function> constructor,
so in addition to a dictionary,
lists of tuples are also acceptable.
</para>
</summary>
</cvar>

<cvar name="SUBSTFILEPREFIX">
<summary>
<para>
The prefix used for &b-link-Substfile; file names,
an empty string by default.
</para>
</summary>
</cvar>

<cvar name="SUBSTFILESUFFIX">
<summary>
<para>
The suffix used for &b-link-Substfile; file names,
an empty string by default.
</para>
</summary>
</cvar>

<cvar name="TEXTFILEPREFIX">
<summary>
<para>
The prefix used for &b-link-Textfile; file names,
an empty string by default.
</para>
</summary>
</cvar>

<cvar name="TEXTFILESUFFIX">
<summary>
<para>
The suffix used for &b-link-Textfile; file names;
<filename>.txt</filename> by default.
</para>
</summary>
</cvar>

<cvar name="FILE_ENCODING">
<summary>
<para>
File encoding used for files written by &b-link-Textfile; and &b-link-Substfile;.
Set to "utf-8" by default.
</para>
<para>
<emphasis>New in version  4.5.0.</emphasis>
</para>
</summary>
</cvar>

</sconsdoc>
